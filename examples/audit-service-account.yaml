# Kubernetes audit ServiceAccount and RBAC configuration example
#
# This configuration creates a dedicated audit ServiceAccount and uses RBAC
# to strictly control permissions, preventing direct access to Secret data.
#
# Usage:
# 1. Update namespace and resource limits as needed
# 2. Apply: kubectl apply -f audit-service-account.yaml
# 3. Get the audit token: kubectl -n <namespace> create token audit-service-account
# 4. Use that token in kubeconfig to configure a new context

---
# ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: audit-service-account
  # namespace: default  # Uncomment and set the target namespace

---
# Dedicated Role: grant only the permissions required for audit (no Secrets)
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: audit-role
  # namespace: default  # Uncomment and set the target namespace
rules:
  # Pod permissions
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]

  # Deployment permissions
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets", "daemonsets", "replicasets"]
    verbs: ["get", "list", "watch"]

  # Other workload permissions
  - apiGroups: ["apps"]
    resources: ["controllerrevisions"]
    verbs: ["get", "list"]

  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch"]

  # ConfigMap permissions (required for sensitive data scan)
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "watch"]

  # Secret permissions (optional)
  # If you are concerned about exposing Secret data during audits, omit this.
  # Without Secret permissions, all other checks still run normally.
  #
  # To enable Secret checks, uncomment the following:
  # - apiGroups: [""]
  #   resources: ["secrets"]
  #   verbs: ["get", "list"]

  # Service permissions (required for network audit)
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "watch"]

  # Ingress permissions (required for network audit)
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch"]

  # NetworkPolicy permissions (required for network audit)
  - apiGroups: ["networking.k8s.io"]
    resources: ["networkpolicies"]
    verbs: ["get", "list", "watch"]

  # RBAC permissions (required for RBAC audit)
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["roles", "rolebindings", "clusterroles", "clusterrolebindings"]
    verbs: ["get", "list", "watch"]

  # PodDisruptionBudget permissions
  - apiGroups: ["policy"]
    resources: ["poddisruptionbudgets"]
    verbs: ["get", "list", "watch"]

  # ServiceAccount permissions
  - apiGroups: [""]
    resources: ["serviceaccounts"]
    verbs: ["get", "list", "watch"]

---
# RoleBinding: bind the Role to the ServiceAccount
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: audit-rolebinding
  # namespace: default  # Uncomment and set the target namespace
subjects:
  - kind: ServiceAccount
    name: audit-service-account
    # namespace: default  # Uncomment and set the target namespace
roleRef:
  kind: Role
  name: audit-role
  apiGroup: rbac.authorization.k8s.io

---
# Optional: audit cluster-level resources (such as ClusterRole)
# Uncomment the following and adjust permissions as needed
#
# apiVersion: rbac.authorization.k8s.io/v1
# kind: ClusterRole
# metadata:
#   name: audit-cluster-role
# rules:
#   - apiGroups: ["rbac.authorization.k8s.io"]
#     resources: ["clusterroles", "clusterrolebindings"]
#     verbs: ["get", "list", "watch"]
#
# ---
# apiVersion: rbac.authorization.k8s.io/v1
# kind: ClusterRoleBinding
# metadata:
#   name: audit-cluster-rolebinding
# subjects:
#   - kind: ServiceAccount
#     name: audit-service-account
#     namespace: default  # Update to the ServiceAccount namespace
# roleRef:
#   kind: ClusterRole
#   name: audit-cluster-role
#   apiGroup: rbac.authorization.k8s.io

---
# Security best practices:
#
# 1. Least privilege: grant only the minimum permissions required for audit
# 2. Secret optional: decide whether to grant Secret permissions per policy
#    - Not granted: skip Secret checks; other checks still run
#    - Granted: Secret type and content checks are available
# 3. Namespace isolation: use Role instead of ClusterRole for namespace scoping
# 4. Regular rotation: periodically audit and rotate ServiceAccount tokens
# 5. Audit logging: enable Kubernetes audit logs to track audit activity
#
# Impact without Secret permissions:
#
# ✅ Checks that still run:
#   - Pod Security (privileged, hostNetwork, capabilities, etc.)
#   - RBAC audit (wildcards, high-privilege roles)
#   - Network security audit (NetworkPolicy, Service, Ingress)
#   - HostPath mount detection (hostPath)
#   - Security policy checks (seccomp, AppArmor)
#   - High availability checks (PDB, ServiceAccount)
#   - ConfigMap sensitive data scanning
#
# ❌ Checks that are skipped:
#   - Secret type checks (whether Secret types are appropriate)
#   - Secret non-sensitive data checks (detect non-sensitive misuse of Secrets)
#
# How to get the audit token:
#
# # Method 1: temporary token (recommended, expires)
# kubectl -n <namespace> create token audit-service-account --duration=1h
#
# # Method 2: long-lived token (not recommended, legacy compatibility)
# kubectl -n <namespace> get secret $(kubectl -n <namespace> get sa audit-service-account -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 -d
#
# Configure kubeconfig with the new context:
#
# # Set the new context
# kubectl config set-context audit-context \
#   --cluster=<your-cluster> \
#   --user=audit-service-account \
#   --namespace=<target-namespace>
#
# # Set user credentials (use the token from above)
# kubectl config set-credentials audit-service-account \
#   --token=<your-token>
